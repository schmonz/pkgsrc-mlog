name: VM

on:
  push:
    branches: ['main']

jobs:
  netbsd:
    name: >
      NetBSD
      ${{ matrix.osversion }}
    runs-on: ubuntu-latest
    strategy:
      fail-fast: true
      matrix:
        osversion: ["9.3"]
    steps:
    - name: Restore bootstrap
      id: bootstrap-restore
      uses: actions/cache/restore@v4
      with:
        path: ~/cached-netbsd-opt-pkg
        key: NetBSD-${{ matrix.osversion }}-bootstrap-${{ github.run_id }}
        restore-keys: NetBSD-${{ matrix.osversion }}-bootstrap-

    - name: Build bootstrap and packages
      id: bootstrap-build
      uses: vmactions/netbsd-vm@v1
      with:
        release: ${{ matrix.osversion }}
        usesh: true
        # sync: rsync
        # copyback: false ### but then I have to explicitly copy back the package
        # XXX raise vmactions issue:
        # optional specific path to copy back when copyback==false
        # use case: my generated release artifacts
        prepare: |
          /usr/sbin/pkg_add git-base
        run: |
          set -e

          # sh: cannot create /home/runner/work/_temp/_runner_file_commands/set_env_3bfecdc6-e85b-47d7-9bfc-f27cdd564145: directory nonexistent
          # XXX raise vmactions issue:
          # this should be handled for me, right?
          mkdir -p $(dirname ${GITHUB_ENV})

          # host GITHUB_WORKSPACE = /home/runner/work/pkgsrc-mlog/pkgsrc-mlog
          # if _not_ sshfs, it's populated here as well
          # if _not_ sshfs, actions/checkout gets mirrored into the VM
          # XXX raise vmactions issue:
          # sshfs maybe isn't working on NetBSD? (try FreeBSD)

          git clone --depth=1 ${GITHUB_SERVER_URL}/NetBSD/pkgsrc
          git clone --depth=1 ${GITHUB_SERVER_URL}/${GITHUB_REPOSITORY} pkgsrc/${GITHUB_REPOSITORY}

          if [ -d ${GITHUB_WORKSPACE}/cached-netbsd-opt-pkg ]; then
            mkdir -p /opt
            mv ${GITHUB_WORKSPACE}/cached-netbsd-opt-pkg /opt/pkg
          else
            unset PKG_PATH
            cd pkgsrc/bootstrap
            ./bootstrap --prefix /opt/pkg
            ./cleanup
            cd ..
          fi
          PATH=/opt/pkg/sbin:/opt/pkg/bin:${PATH}
          cd ${GITHUB_REPOSITORY}
          bmake package

          mkdir ${GITHUB_WORKSPACE}/release-contents

          release_version=$(bmake show-var VARNAME=PKGVERSION)

          mv $(bmake show-var VARNAME=PKGFILE) ${GITHUB_WORKSPACE}/release-contents
          cd ${GITHUB_WORKSPACE}/release-contents
          for i in *.tgz; do
            mv $i NetBSD-${{ matrix.osversion }}-unprivileged-$i
          done
          release_asset=$(echo *.tgz)

          echo "release_version=${release_version}" >> "${GITHUB_ENV}"
          echo "release_asset=${GITHUB_WORKSPACE}/release-contents/${release_asset}" >> "${GITHUB_ENV}"

          # put installed package tools where rsync can copy them out to host
          mv /opt/pkg ${GITHUB_WORKSPACE}/cached-netbsd-opt-pkg

          # XXX raise vmactions issue:
          # optional additional paths for rsyncToVM/rsyncBackFromVM
          # my use case: bootstrap in the VM, rsync to benefit from actions/cache
          rm -rf ${GITHUB_WORKSPACE}/pkgsrc

          # XXX cross-platform-actions/action looks cool as well

    - name: Save bootstrap
      id: bootstrap-save
      uses: actions/cache/save@v4
      if: always()
      with:
        path: ~/cached-netbsd-opt-pkg
        key: ${{ steps.bootstrap-restore.outputs.cache-primary-key }}

    - name: Pretend to publish package
      run: |
        set -e
        echo "VERSION: version ${{ env.release_version }}"
        echo "FILE: ${{ env.release_asset }}"

    - name: Publish package
      uses: softprops/action-gh-release@v1
      if: false
      with:
        files: ${{ env.release_asset }}
        name: ${{ env.release_version }}
